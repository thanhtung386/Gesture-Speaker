#include "BluetoothA2DPSink.h"
#include <EEPROM.h>
#include <FirebaseESP32.h>
#include <WiFi.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_NeoPixel.h>
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
BluetoothA2DPSink a2dp_sink;
FirebaseData firebaseData;
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire);
int ges[6];

#define FIREBASE_HOST "https://gesture-speaker-91107-default-rtdb.asia-southeast1.firebasedatabase.app/"
#define FIREBASE_Authorization_key "ithgiGhy9OD8QaM3ca4iJHf4ycQUq6ypBHRa11b1"
#define WIFI_SSID "MERCUSYS_83B1" // Change the name of your WIFI
#define WIFI_PASSWORD "B5810B5810" // Change the password of your WIFI

#define EEPROM_SIZE 7 //Tương ứng 7 ô nhớ
//1. play 2. pause
//3. next 4. prev
//5. volume_up 6. volume_down
#define led 2
#define btn_update 25 //Nút chuyển sang chức năng cập nhật chức năng cử chỉ
#define btn_1 27 // Cử chỉ 1 - top
#define btn_2 26 // Cử chỉ 2 - botom
#define btn_3 4 // Cử chỉ 3 - right
#define btn_4 5 // Cử chỉ 4 - left
#define btn_5 18 // Cử chỉ 5 - up
#define btn_6 19 // Cử chỉ 6 - down
#define LED_PIN 15
#define NUMPIXELS 8
Adafruit_NeoPixel pixels(NUMPIXELS, LED_PIN, NEO_GRB + NEO_KHZ800);
static const uint8_t image_previous[128] = {
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x01, 0x80, 0x0e, 
0x00, 0x07, 0x80, 0x1e, 
0x00, 0x0f, 0x80, 0x7e, 
0x00, 0x3f, 0x80, 0xfe, 
0x00, 0x7f, 0x83, 0xfe, 
0x01, 0xff, 0x87, 0xfe, 
0x03, 0xff, 0x9f, 0xfe, 
0x0f, 0xff, 0xbf, 0xfe, 
0x1f, 0xff, 0xff, 0xfe, 
0x7f, 0xff, 0xff, 0xfe, 
0xff, 0xff, 0xff, 0xfe, 
0xff, 0xff, 0xff, 0xfe, 
0x7f, 0xff, 0xff, 0xfe, 
0x1f, 0xff, 0xff, 0xfe, 
0x0f, 0xff, 0xbf, 0xfe, 
0x03, 0xff, 0x9f, 0xfe, 
0x01, 0xff, 0x87, 0xfe, 
0x00, 0x7f, 0x83, 0xfe, 
0x00, 0x3f, 0x80, 0xfe, 
0x00, 0x0f, 0x80, 0x7e, 
0x00, 0x07, 0x80, 0x1e, 
0x00, 0x01, 0x80, 0x0e, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00  
};
static const uint8_t image_next[128] = {
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x70, 0x01, 0x80, 0x00, 
0x78, 0x01, 0xe0, 0x00, 
0x7e, 0x01, 0xf0, 0x00, 
0x7f, 0x01, 0xfc, 0x00, 
0x7f, 0xc1, 0xfe, 0x00, 
0x7f, 0xe1, 0xff, 0x80, 
0x7f, 0xf9, 0xff, 0xc0, 
0x7f, 0xfd, 0xff, 0xf0, 
0x7f, 0xff, 0xff, 0xf8, 
0x7f, 0xff, 0xff, 0xfe, 
0x7f, 0xff, 0xff, 0xff, 
0x7f, 0xff, 0xff, 0xff, 
0x7f, 0xff, 0xff, 0xfe, 
0x7f, 0xff, 0xff, 0xf8, 
0x7f, 0xfd, 0xff, 0xf0, 
0x7f, 0xf9, 0xff, 0xc0, 
0x7f, 0xe1, 0xff, 0x80, 
0x7f, 0xc1, 0xfe, 0x00, 
0x7f, 0x01, 0xfc, 0x00, 
0x7e, 0x01, 0xf0, 0x00, 
0x78, 0x01, 0xe0, 0x00, 
0x70, 0x01, 0x80, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00  
};
static const uint8_t image_pause[128] = {
  0x00, 0x3f, 0xfc, 0x00, 
0x00, 0xff, 0xff, 0x00, 
0x03, 0xff, 0xff, 0xc0, 
0x07, 0xff, 0xff, 0xe0, 
0x0f, 0xf0, 0x0f, 0xf0, 
0x1f, 0xc0, 0x03, 0xf8, 
0x3f, 0x00, 0x00, 0xfc, 
0x3e, 0x00, 0x00, 0x7c, 
0x7c, 0x00, 0x00, 0x3e, 
0x7c, 0x00, 0x00, 0x3e, 
0xf8, 0x0e, 0x00, 0x1f, 
0xf8, 0x0f, 0x00, 0x1f, 
0xf0, 0x0f, 0xc0, 0x0f, 
0xf0, 0x0f, 0xf0, 0x0f, 
0xf0, 0x0f, 0xf8, 0x0f, 
0xf0, 0x0f, 0xfe, 0x0f, 
0xf0, 0x0f, 0xfe, 0x0f, 
0xf0, 0x0f, 0xfc, 0x0f, 
0xf0, 0x0f, 0xf0, 0x0f, 
0xf0, 0x0f, 0xc0, 0x0f, 
0xf8, 0x0f, 0x80, 0x1f, 
0xf8, 0x0e, 0x00, 0x1f, 
0x7c, 0x00, 0x00, 0x3e, 
0x7c, 0x00, 0x00, 0x3e, 
0x3e, 0x00, 0x00, 0x7c, 
0x3f, 0x00, 0x00, 0xfc, 
0x1f, 0xc0, 0x03, 0xf8, 
0x0f, 0xf0, 0x0f, 0xf0, 
0x07, 0xff, 0xff, 0xe0, 
0x03, 0xff, 0xff, 0xc0, 
0x00, 0xff, 0xff, 0x00, 
0x00, 0x1f, 0xfc, 0x00
};

static const uint8_t image_continue[128] = {
0x00, 0x0f, 0xf0, 0x00, 
0x00, 0x7f, 0xfe, 0x00, 
0x01, 0xff, 0xff, 0x80, 
0x03, 0xff, 0xff, 0xc0, 
0x07, 0xff, 0xff, 0xe0, 
0x0f, 0xff, 0xff, 0xf0, 
0x1f, 0xff, 0xff, 0xf8, 
0x3f, 0xff, 0xff, 0xfc, 
0x3f, 0xc7, 0xc3, 0xfc, 
0x7f, 0xc3, 0xc3, 0xfe, 
0x7f, 0xe3, 0xc3, 0xfe, 
0xff, 0xc3, 0xc3, 0xfe, 
0xff, 0xc3, 0xc3, 0xff, 
0xff, 0xc7, 0xc3, 0xff, 
0xff, 0xc3, 0xc7, 0xff, 
0xff, 0xc3, 0xe3, 0xff, 
0xff, 0xe3, 0xc3, 0xff, 
0xff, 0xc3, 0xc3, 0xff, 
0xff, 0xc3, 0xc3, 0xff, 
0xff, 0xc7, 0xc3, 0xfe, 
0xff, 0xc3, 0xe3, 0xfe, 
0x7f, 0xc3, 0xc3, 0xfe, 
0x7f, 0xc3, 0xc3, 0xfe, 
0x3f, 0xc7, 0xe7, 0xfc, 
0x3f, 0xff, 0xff, 0xfc, 
0x1f, 0xff, 0xff, 0xf8, 
0x0f, 0xff, 0xff, 0xf0, 
0x0f, 0xff, 0xff, 0xe0, 
0x03, 0xff, 0xff, 0xc0, 
0x01, 0xff, 0xff, 0x80, 
0x00, 0x7f, 0xfe, 0x00, 
0x00, 0x1f, 0xf0, 0x00
};

static const uint8_t image_volume[128] = {
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xc0, 0x60, 
0x00, 0x03, 0xc0, 0x30, 
0x00, 0x07, 0xc0, 0x38, 
0x00, 0x0f, 0xc3, 0x98, 
0x00, 0x1f, 0xc1, 0x9c, 
0x00, 0x3f, 0xc1, 0xcc, 
0x3f, 0xff, 0x9c, 0xcc, 
0x7f, 0xff, 0xcc, 0xee, 
0x7f, 0xff, 0xcc, 0x64, 
0x3f, 0xff, 0xc6, 0x66, 
0x7f, 0xff, 0xc6, 0x66, 
0x7f, 0xff, 0xce, 0x66, 
0x3f, 0xff, 0xc6, 0x66, 
0x7f, 0xff, 0xc6, 0x66, 
0x7f, 0xff, 0xcc, 0xe6, 
0x3f, 0xff, 0x8c, 0xcc, 
0x24, 0xff, 0xd8, 0xcc, 
0x00, 0x1f, 0xc1, 0xcc, 
0x00, 0x1f, 0xc3, 0x9c, 
0x00, 0x07, 0xc1, 0x18, 
0x00, 0x03, 0xc0, 0x30, 
0x00, 0x01, 0xc0, 0x70, 
0x00, 0x00, 0x80, 0x20, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00
};

//Hàm xóa từng dòng trên oled
void clear_line(int line){
  for (int y = line*8; y< line*8 +8; y++){
    for (int x=0; x<128; x++){
        display.drawPixel(x, y, BLACK); 
       }
  }
}
//In tiêu đề bài hát
void avrc_metadata_callback(uint8_t id, const uint8_t *text) {
  if (id== ESP_AVRC_MD_ATTR_TITLE){
  clear_line(0);
  clear_line(1);
  clear_line(2);
  display.setCursor(0,0);
  display.print((char *)text);
  display.display();
  }
}
//Hiển thị volume khi thay đổi
void volumeChanged(int new_volume) {
  EEPROM.write(0, new_volume);
  EEPROM.commit(); 
  clean_insert_image(image_volume);
  display.setCursor(54,56);
  display.print(int(new_volume*0.7878));
  display.display(); 
}
//Kiểm tra trạng thái kết nối
void connection_state_changed(esp_a2d_connection_state_t state, void *ptr) {
  if (a2dp_sink.to_str(state) == "Connected") {
    digitalWrite(led, HIGH);
  }
  else digitalWrite(led, LOW);
}
//Hiển thị trạng thái khi thay đổi
void audio_state_changed(esp_a2d_audio_state_t state, void *ptr) {
  if (a2dp_sink.to_str(state) == "Suspended") {
    clean_insert_image(image_pause);
    Serial.println("Suspended");
  }
  else if(a2dp_sink.to_str(state) == "Started"){
    clean_insert_image(image_continue);
    Serial.println("Started");
  }
}
//Xóa và cập nhật lại hình
void clean_insert_image(const uint8_t* image){
    clear_line(3);  
    clear_line(4);  
    clear_line(5);  
    clear_line(6);  
    clear_line(7);
    display.drawBitmap(43, 24, image, 32, 32,1);
    display.display();
}
//Thực nhiện chức năng cập nhật cử chỉ
void custom(){
  WiFi.begin (WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting...");
  while (WiFi.status() != WL_CONNECTED)
  {
    Serial.print(".");
    delay(300);
  }
  Serial.println();
  Serial.print("IP Address: ");
  Serial.println(WiFi.localIP());
  Serial.println();
  Firebase.begin(FIREBASE_HOST,FIREBASE_Authorization_key);
  if(Firebase.getString(firebaseData,"/top")){
    ges[0] = (firebaseData.stringData()).toInt();
    EEPROM.write(1, ges[0]);  
    display.fillRect(0, 40, 20, 20,WHITE);
    display.display();
  }
    if(Firebase.getString(firebaseData,"/botom")){
    ges[1] = (firebaseData.stringData()).toInt();
    EEPROM.write(2, ges[1]);
    display.fillRect(20, 40, 20, 20,WHITE);
    display.display();    
  }
    if(Firebase.getString(firebaseData,"/right")){
    ges[2] = (firebaseData.stringData()).toInt();
    EEPROM.write(3, ges[2]);
    display.fillRect(40, 40, 20, 20,WHITE);
    display.display();     
  }
    if(Firebase.getString(firebaseData,"/left")){
    ges[3] = (firebaseData.stringData()).toInt();
    EEPROM.write(4, ges[3]);
    display.fillRect(60, 40, 20, 20,WHITE);
    display.display();     
  }
  if(Firebase.getString(firebaseData,"/up")){
    ges[4] = (firebaseData.stringData()).toInt();
    EEPROM.write(5, ges[4]);
    display.fillRect(80, 40, 20, 20,WHITE);
    display.display();     
  }
  if(Firebase.getString(firebaseData,"/down")){
    ges[5] = (firebaseData.stringData()).toInt();
    EEPROM.write(6, ges[5]);
    display.fillRect(100, 40, 20, 20,WHITE);
    display.display();    
  }
  EEPROM.commit();  
  clear_line(3);
  display.setCursor(15,24); 
  display.print("UPDATING SUCESS");       
  display.display(); 
}
//Kiểm tra và thực thi chức năng tương ứng với cử chỉ
void check(int gesture){
  if(gesture == 1) {
    a2dp_sink.play();
    clean_insert_image(image_continue);
  }
  if(gesture == 2) {
    a2dp_sink.pause();
    clean_insert_image(image_pause);
  }
  if(gesture == 3) {
    a2dp_sink.next();
    clean_insert_image(image_next);
  }
  if(gesture == 4) {
    a2dp_sink.previous();
    clean_insert_image(image_previous);
  }
  if (gesture == 5) {
    EEPROM.write(0, a2dp_sink.get_volume());
    EEPROM.commit();
    a2dp_sink.set_volume(a2dp_sink.get_volume() + 10);  
    clean_insert_image(image_volume);
    display.setCursor(54,56);
    display.print(int(a2dp_sink.get_volume()*0.7878));
    display.display();      
  }
  if (gesture == 6) {
    EEPROM.write(0, a2dp_sink.get_volume());
    EEPROM.commit();
    a2dp_sink.set_volume(a2dp_sink.get_volume() - 10); 
    clean_insert_image(image_volume);
    display.setCursor(54,56);    
    display.print(int(a2dp_sink.get_volume()*0.7878));
    display.display();       
  }  
}

void setup() {
    Serial.begin(115200);  
    
    pinMode(led, OUTPUT);
    pinMode(btn_update, INPUT_PULLUP);  
    pinMode(btn_1, INPUT_PULLUP);
    pinMode(btn_2, INPUT_PULLUP);
    pinMode(btn_3, INPUT_PULLUP);
    pinMode(btn_4, INPUT_PULLUP);
    pinMode(btn_5, INPUT_PULLUP);
    pinMode(btn_6, INPUT_PULLUP);
    
    EEPROM.begin(EEPROM_SIZE);  
    for(int g = 0; g<6;g++){
      ges[g] = EEPROM.read(g+1);
    }
    
    i2s_pin_config_t my_pin_config = {
        .bck_io_num = 12,
        .ws_io_num = 13,
        .data_out_num = 14,
        .data_in_num = I2S_PIN_NO_CHANGE
    };
    a2dp_sink.set_pin_config(my_pin_config);   
    a2dp_sink.start("GESTURE SPEAKER");
    a2dp_sink.set_volume(EEPROM.read(0));
    a2dp_sink.set_on_connection_state_changed(connection_state_changed);
    a2dp_sink.set_on_audio_state_changed(audio_state_changed);
    a2dp_sink.set_avrc_metadata_callback(avrc_metadata_callback);
    a2dp_sink.set_on_volumechange(volumeChanged);      

    Wire.begin();      
    display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
    if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;);
    }
    delay(500);
    display.clearDisplay();
    display.setTextColor(WHITE);
    pixels.begin();
}

void animation_led_1(){
  pixels.clear();
  for(int i=0; i<NUMPIXELS; i++) {
    pixels.setPixelColor(i, pixels.Color(0, 150, 0));
    pixels.show();   // Send the updated pixel colors to the hardware.
    delay(500); // Pause before next pass through loop
  }
}
void loop() {
  if(digitalRead(btn_update) == 0)
    { 
       a2dp_sink.disconnect();
       a2dp_sink.end(true);
       clear_line(3);
       clear_line(4);
       clear_line(5);
       clear_line(6);
       clear_line(7);
       display.setCursor(15,24); 
       display.print("UPDATING GESTURE");       
       display.display(); 
       custom();    
       ESP.restart();    
    }
    else
    {
      delay(150);
        if (digitalRead(btn_1) == 0) check(ges[0]);
        if (digitalRead(btn_2) == 0) check(ges[1]);
        if (digitalRead(btn_3) == 0) check(ges[2]);
        if (digitalRead(btn_4) == 0) check(ges[3]);
        if (digitalRead(btn_5) == 0) check(ges[4]);
        if (digitalRead(btn_6) == 0) check(ges[5]);  
    }
}
